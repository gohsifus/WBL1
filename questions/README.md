# Ответы на вопросы

## 1. Какой самый эффективный способ конкатенации строк?
**strings.Builder{}** - самый эффективный. Конкантенировать строки через оператор += нельзя так как строки в go не изменяемы, и при += создается новая строка.
## 2. Что такое интерфейсы, как они применяются в Go?
**Интерфейс в go - это** набор методов для реализации в других типах. Если тип имеет все методы перечисленные в интерфейсе, то такой тип соответствует этому интерфейсу.
**Применение** - благодаря интерфейсам методы могут использовать обьекты разных типов реализующих один интерфейс, что позволяет уменьшить дублирование кода (не нужно реализовывать один и тот же метод для каждого типа), облегчить тестирование (можно легко подменить реальный входной обьект метода заглушкой реализующей тот же интерфейс).
## 3. Чем отличаются RWMutex от Mutex?
RWMutex позволяет организовать "блокировку читателя", которая позволяет операциям чтения выполняться параллельно друг другу, а операции записи получают исключительный доступ.
**Проще говоря - при использовании RWMutex блокировку может удерживать множество читателей или один писатель, а при использовании Mutex блокировку может удерживать любой процесс.**
## 4. Чем отличаются буферизированные и не буферизированные каналы?
Буферизированные каналы позволяют хранить несколько значений, и соответственно рутины могут записывать несколько значений не блокируясь.
## 5. Какой размер у структуры struct{}{}?
**0**, пустая структура ничего не весит, поэтому ее удобно использовать например в map, когда нам важны только ключи.
## 6. Есть ли в Go перегрузка методов или операторов?
**Нет**. Перегрузка методов - когда можно определить несколько функций с одинаковым названием но разными параметрами, в таком случае компилятор сам решает какой метод вызвать на основе параметров.
## 7. В какой последовательности будут выведены элементы map[int]int?
В golang **порядок итераций по map не определен**.
## 8. В чем разница make и new?
**make работает только с картой слайсом или каналом, и не возвращает указатель, make инициализирует обьект, а new только аллоцирует память**.
## 9. Сколько существует способов задать переменную типа slice или map?
**3 make, new и с помощью литералов.**
## 10. Что выведет данная программа и почему?
```
unc update(p *int) {
	b := 2
	p = &b
}
func main() {
	var (
		a = 1
		p = &a
	)

	fmt.Println(*p)
	update(p)
	fmt.Println(*p)
}
```
**1 1** потому что в go все передается по значению, в данном случае в метод мы передаем и изменяем копию указателя.
## 11. Что выведет данная программа и почему?
```
func main() {
	wg := sync.WaitGroup{}
	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func(wg sync.WaitGroup, i int) {
			fmt.Println(i)
			wg.Done()
		}(wg, i)
	}
	wg.Wait()
	fmt.Println("exit")
}
```
Будет выведено какое-то количество значений цикла, далее произойдет блокировка, потому что waitGroup нельзя копировать после первого использования.
```
// A WaitGroup must not be copied after first use.
type WaitGroup struct {
	noCopy noCopy
```
У структуры noCopy есть метод блокировки, который видимо блокирует рутину при попытке копирования, а так как блокируется главный поток возникает ошибка.
## 12. Что выведет данная программа и почему?
```
func main() {
    n := 0
    if true {
        n := 1
        n++ 
    }
    fmt.Println(n)
}
```
**0** - в го область видимости переменных задается фигурными скобками, поскольку в области if мы создали и изменяли новую переменную n, это не повлияло на n в более высокой области видимости.
## 13. Что выведет данная программа и почему?
```
func someAction(v []int8, b int8) {
    v[0] = 100
    v = append(v, b)
}

func main() {
    var a = []int8{1, 2, 3, 4, 5}
    someAction(a, 6)
    fmt.Println(a)
}
```
**{100, 2, 3, 4, 5}** - слайс это структура состоящая из 3 полей: указатель на область памяти, длина и вместимость, v[0] = 100 изменит 0 элемент в слайсе с помощью этого указателя.
Но элемент 6 не будет добавлен в слайс, так как в функцию передается только копия.
## 14. Что выведет данная программа и почему?
```
func main() {
    slice := []string{"a", "a"}
    func(slice []string) {
        slice = append(slice, "a")
        slice[0] = "b"
        slice[1] = "b"
        fmt.Print(slice)
    }(slice)
    fmt.Print(slice)
}
```
**{b, b, a} {a, a}** - в функцию мы передаем копию слайса, затем append перевыделяет новый массив для слайса чтобы увеличить capacity, далее в копии слайса, с новым массивом мы меняем индексы элементов, соответственно изменения никак не затронут slice в родителской области видимости.